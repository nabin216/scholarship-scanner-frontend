"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/Authentication/register/page",{

/***/ "(app-pages-browser)/./src/app/Authentication/context/AuthContext.tsx":
/*!********************************************************!*\
  !*** ./src/app/Authentication/context/AuthContext.tsx ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _services_apiService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../services/apiService */ \"(app-pages-browser)/./src/services/apiService.ts\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Check if the user is already authenticated on mount\n        const checkAuth = async ()=>{\n            const token = localStorage.getItem(\"authToken\");\n            if (token) {\n                try {\n                    const verifyResponse = await fetch(_services_apiService__WEBPACK_IMPORTED_MODULE_3__.ApiService.getApiUrl(\"user/auth/token/verify/\"), {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            token\n                        })\n                    });\n                    if (!verifyResponse.ok) {\n                        console.log(\"Token invalid, status:\", verifyResponse.status);\n                        // Try to use refresh token if available\n                        const refreshToken = localStorage.getItem(\"refreshToken\");\n                        if (refreshToken) {\n                            try {\n                                const refreshResponse = await fetch(_services_apiService__WEBPACK_IMPORTED_MODULE_3__.ApiService.getApiUrl(\"user/auth/token/refresh/\"), {\n                                    method: \"POST\",\n                                    headers: {\n                                        \"Content-Type\": \"application/json\"\n                                    },\n                                    body: JSON.stringify({\n                                        refresh: refreshToken\n                                    })\n                                });\n                                if (refreshResponse.ok) {\n                                    const refreshData = await refreshResponse.json();\n                                    localStorage.setItem(\"authToken\", refreshData.access);\n                                    // Continue with the new token\n                                    fetchUserData(refreshData.access);\n                                    return;\n                                }\n                            } catch (refreshError) {\n                                console.error(\"Token refresh failed:\", refreshError);\n                            }\n                        }\n                        // If we get here, both token verify and refresh failed\n                        localStorage.removeItem(\"authToken\");\n                        localStorage.removeItem(\"refreshToken\");\n                        setUser(null);\n                        setIsAuthenticated(false);\n                        setLoading(false);\n                        return;\n                    }\n                    // Token is valid, get user data\n                    await fetchUserData(token);\n                } catch (error) {\n                    console.error(\"Authentication check failed:\", error);\n                    localStorage.removeItem(\"authToken\");\n                    localStorage.removeItem(\"refreshToken\");\n                    setUser(null);\n                    setIsAuthenticated(false);\n                    setLoading(false);\n                }\n            } else {\n                setLoading(false);\n            }\n        };\n        const fetchUserData = async (token)=>{\n            try {\n                const response = await fetch(_services_apiService__WEBPACK_IMPORTED_MODULE_3__.ApiService.getApiUrl(\"user/auth/me/\"), {\n                    headers: {\n                        \"Authorization\": \"Bearer \".concat(token),\n                        \"Content-Type\": \"application/json\"\n                    },\n                    credentials: \"include\"\n                });\n                if (response.ok) {\n                    const userData = await response.json();\n                    setUser({\n                        id: userData.id,\n                        name: userData.full_name || userData.name,\n                        email: userData.email\n                    });\n                    setIsAuthenticated(true);\n                    console.log(\"User authenticated successfully on page refresh\");\n                } else {\n                    console.log(\"Failed to get user data, status:\", response.status);\n                    // Token might be valid but user data fetch failed\n                    localStorage.removeItem(\"authToken\");\n                    setUser(null);\n                    setIsAuthenticated(false);\n                }\n            } catch (error) {\n                console.error(\"Authentication check failed:\", error);\n                localStorage.removeItem(\"authToken\");\n                setUser(null);\n                setIsAuthenticated(false);\n            }\n            setLoading(false);\n        };\n        checkAuth();\n    }, []);\n    const loginWithGoogle = async ()=>{\n        // Open Google OAuth popup\n        const width = 500;\n        const height = 600;\n        const left = window.screenX + (window.outerWidth - width) / 2;\n        const top = window.screenY + (window.outerHeight - height) / 2;\n        // Construct Google OAuth URL\n        const googleOAuthUrl = \"https://accounts.google.com/o/oauth2/v2/auth?\" + \"client_id=\".concat(_services_apiService__WEBPACK_IMPORTED_MODULE_3__.ApiService.getConfig().googleClientId) + \"&redirect_uri=\".concat(encodeURIComponent(_services_apiService__WEBPACK_IMPORTED_MODULE_3__.ApiService.getConfig().googleOAuthRedirectUri)) + \"&response_type=id_token\" + \"&scope=\".concat(encodeURIComponent(\"openid email profile\")) + \"&nonce=\".concat(Math.random().toString(36).substring(2, 15)) + \"&prompt=select_account\"; // Open the Google OAuth popup\n        const popup = window.open(googleOAuthUrl, \"Google Login\", \"width=\".concat(width, \",height=\").concat(height, \",left=\").concat(left, \",top=\").concat(top, \",toolbar=no,menubar=no,location=no,status=no\"));\n        // Create a message listener to handle the callback\n        window.addEventListener(\"message\", async (event)=>{\n            // Only accept messages from our own domain\n            if (event.origin !== window.location.origin) return;\n            if (event.data.type === \"GOOGLE_AUTH_SUCCESS\") {\n                if (popup) popup.close();\n                try {\n                    await handleGoogleCallback(event.data.token, event.data.user);\n                    router.push(\"/profile\");\n                } catch (error) {\n                    console.error(\"Google auth callback error:\", error);\n                }\n            }\n        });\n    };\n    const handleGoogleCallback = async (token, userData)=>{\n        try {\n            const response = await fetch(_services_apiService__WEBPACK_IMPORTED_MODULE_3__.ApiService.getApiUrl(\"user/auth/google/token/\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                credentials: \"include\",\n                body: JSON.stringify({\n                    id_token: token,\n                    email: userData.email,\n                    full_name: userData.name\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Google authentication failed\");\n            }\n            const data = await response.json();\n            console.log(\"Google auth response:\", data);\n            // Store tokens based on what's returned\n            if (data.access) {\n                // JWT format\n                localStorage.setItem(\"authToken\", data.access);\n                if (data.refresh) {\n                    localStorage.setItem(\"refreshToken\", data.refresh);\n                }\n            } else if (data.token) {\n                // Legacy token format\n                localStorage.setItem(\"authToken\", data.token);\n            }\n            setUser({\n                id: data.user.id,\n                name: data.user.full_name,\n                email: data.user.email\n            });\n            setIsAuthenticated(true);\n        } catch (error) {\n            console.error(\"Google auth error:\", error);\n            throw error;\n        }\n    };\n    const login = async (email, password)=>{\n        setLoading(true);\n        try {\n            var _data_user, _data_user1, _data_user2, _data_user3;\n            // Clear any existing tokens first\n            localStorage.removeItem(\"authToken\");\n            localStorage.removeItem(\"refreshToken\");\n            const response = await fetch(_services_apiService__WEBPACK_IMPORTED_MODULE_3__.ApiService.getApiUrl(\"user/auth/login/\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    email,\n                    password\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || \"Login failed\");\n            }\n            const data = await response.json();\n            console.log(\"Login response:\", data);\n            // Store tokens - we're using JWT which returns access and refresh tokens\n            if (data.access) {\n                localStorage.setItem(\"authToken\", data.access);\n            } else if (data.token) {\n                // Fallback for non-JWT authentication\n                localStorage.setItem(\"authToken\", data.token);\n            }\n            if (data.refresh) {\n                localStorage.setItem(\"refreshToken\", data.refresh);\n            }\n            // Update user state\n            setUser({\n                id: (_data_user = data.user) === null || _data_user === void 0 ? void 0 : _data_user.id,\n                name: ((_data_user1 = data.user) === null || _data_user1 === void 0 ? void 0 : _data_user1.full_name) || ((_data_user2 = data.user) === null || _data_user2 === void 0 ? void 0 : _data_user2.name),\n                email: ((_data_user3 = data.user) === null || _data_user3 === void 0 ? void 0 : _data_user3.email) || email\n            });\n            setIsAuthenticated(true);\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        } finally{\n            setLoading(false); // Make sure loading is always set to false\n        }\n    };\n    const logout = ()=>{\n        localStorage.removeItem(\"authToken\");\n        localStorage.removeItem(\"refreshToken\");\n        setUser(null);\n        setIsAuthenticated(false);\n        // Redirect to login page\n        router.push(\"/Authentication/login\");\n    };\n    const value = {\n        user,\n        loading,\n        login,\n        logout,\n        loginWithGoogle,\n        handleGoogleCallback,\n        isAuthenticated\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\ScholarshipPortal\\\\scholarship-portal\\\\src\\\\app\\\\Authentication\\\\context\\\\AuthContext.tsx\",\n        lineNumber: 295,\n        columnNumber: 10\n    }, this);\n}\n_s(AuthProvider, \"l0f2cJVvoD9s2nghHVOe+1CbBy0=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthProvider;\nconst useAuth = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error(\"useAuth must be used within an AuthProvider\");\n    }\n    return context;\n};\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvQXV0aGVudGljYXRpb24vY29udGV4dC9BdXRoQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRXlGO0FBQzdDO0FBQ2M7QUFnQzFELE1BQU1PLDRCQUFjTixvREFBYUEsQ0FBOEJPO0FBRXhELFNBQVNDLGFBQWEsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQzs7SUFDM0IsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdULCtDQUFRQSxDQUFjO0lBQzlDLE1BQU0sQ0FBQ1UsU0FBU0MsV0FBVyxHQUFHWCwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNZLGlCQUFpQkMsbUJBQW1CLEdBQUdiLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU1jLFNBQVNaLDBEQUFTQTtJQUV4QkQsZ0RBQVNBLENBQUM7UUFDUixzREFBc0Q7UUFDdEQsTUFBTWMsWUFBWTtZQUNoQixNQUFNQyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7WUFFbkMsSUFBSUYsT0FBTztnQkFDVCxJQUFJO29CQUNGLE1BQU1HLGlCQUFpQixNQUFNQyxNQUFNakIsNERBQVVBLENBQUNrQixTQUFTLENBQUMsNEJBQTRCO3dCQUNsRkMsUUFBUTt3QkFDUkMsU0FBUzs0QkFDUCxnQkFBZ0I7d0JBQ2xCO3dCQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7NEJBQUVWO3dCQUFNO29CQUMvQjtvQkFFQSxJQUFJLENBQUNHLGVBQWVRLEVBQUUsRUFBRTt3QkFDdEJDLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEJWLGVBQWVXLE1BQU07d0JBQzNELHdDQUF3Qzt3QkFDeEMsTUFBTUMsZUFBZWQsYUFBYUMsT0FBTyxDQUFDO3dCQUMxQyxJQUFJYSxjQUFjOzRCQUFlLElBQUk7Z0NBQ2pDLE1BQU1DLGtCQUFrQixNQUFNWixNQUFNakIsNERBQVVBLENBQUNrQixTQUFTLENBQUMsNkJBQTZCO29DQUNwRkMsUUFBUTtvQ0FDUkMsU0FBUzt3Q0FD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O1FBQ3pCQyxPQUFPZ0UsSUFBSSxDQUFDO0lBQ2Q7SUFFQSxNQUFNUSxRQUFRO1FBQ1o5RTtRQUNBRTtRQUNBd0U7UUFDQUc7UUFDQXBDO1FBQ0E0QjtRQUNBakU7SUFDRjtJQUVBLHFCQUFPLDhEQUFDUixZQUFZbUYsUUFBUTtRQUFDRCxPQUFPQTtrQkFBUS9FOzs7Ozs7QUFDOUM7R0FqUWdCRDs7UUFJQ0osc0RBQVNBOzs7S0FKVkk7QUFtUVQsTUFBTWtGLFVBQVU7O0lBQ3JCLE1BQU1DLFVBQVUxRixpREFBVUEsQ0FBQ0s7SUFDM0IsSUFBSXFGLFlBQVlwRixXQUFXO1FBQ3pCLE1BQU0sSUFBSTRFLE1BQU07SUFDbEI7SUFDQSxPQUFPUTtBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9BdXRoZW50aWNhdGlvbi9jb250ZXh0L0F1dGhDb250ZXh0LnRzeD8zMTdiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcclxuaW1wb3J0IHsgQXBpU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZpY2VzL2FwaVNlcnZpY2UnO1xyXG5cclxuaW50ZXJmYWNlIFVzZXJQcm9maWxlIHtcclxuICBiaW8/OiBzdHJpbmc7XHJcbiAgZWR1Y2F0aW9uPzogc3RyaW5nO1xyXG4gIHBob25lX251bWJlcj86IHN0cmluZztcclxuICBjb3VudHJ5Pzogc3RyaW5nO1xyXG4gIGRhdGVfb2ZfYmlydGg/OiBzdHJpbmc7XHJcbiAgcHJvZmlsZV9waWN0dXJlPzogc3RyaW5nO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVXNlciB7XHJcbiAgaWQ/OiBzdHJpbmc7XHJcbiAgbmFtZT86IHN0cmluZztcclxuICBlbWFpbDogc3RyaW5nO1xyXG4gIGZ1bGxfbmFtZT86IHN0cmluZztcclxuICBmaXJzdF9uYW1lPzogc3RyaW5nO1xyXG4gIGxhc3RfbmFtZT86IHN0cmluZztcclxuICBwcm9maWxlPzogVXNlclByb2ZpbGU7XHJcbiAgZGF0ZV9qb2luZWQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBBdXRoQ29udGV4dFR5cGUge1xyXG4gIHVzZXI6IFVzZXIgfCBudWxsO1xyXG4gIGxvYWRpbmc6IGJvb2xlYW47XHJcbiAgbG9naW46IChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGxvZ291dDogKCkgPT4gdm9pZDtcclxuICBsb2dpbldpdGhHb29nbGU6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgaGFuZGxlR29vZ2xlQ2FsbGJhY2s6ICh0b2tlbjogc3RyaW5nLCB1c2VyRGF0YTogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcclxufVxyXG5cclxuY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEF1dGhDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBBdXRoUHJvdmlkZXIoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSkge1xyXG4gIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IHVzZVN0YXRlPFVzZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcclxuICBjb25zdCBbaXNBdXRoZW50aWNhdGVkLCBzZXRJc0F1dGhlbnRpY2F0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHVzZXIgaXMgYWxyZWFkeSBhdXRoZW50aWNhdGVkIG9uIG1vdW50XHJcbiAgICBjb25zdCBjaGVja0F1dGggPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgdHJ5IHsgICAgICAgICAgLy8gRmlyc3QsIHZlcmlmeSB0aGUgdG9rZW4gaXMgdmFsaWRcclxuICAgICAgICAgIGNvbnN0IHZlcmlmeVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goQXBpU2VydmljZS5nZXRBcGlVcmwoJ3VzZXIvYXV0aC90b2tlbi92ZXJpZnkvJyksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRva2VuIH0pLFxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaWYgKCF2ZXJpZnlSZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRva2VuIGludmFsaWQsIHN0YXR1czpcIiwgdmVyaWZ5UmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgICAgICAgLy8gVHJ5IHRvIHVzZSByZWZyZXNoIHRva2VuIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICBjb25zdCByZWZyZXNoVG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncmVmcmVzaFRva2VuJyk7XHJcbiAgICAgICAgICAgIGlmIChyZWZyZXNoVG9rZW4pIHsgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChBcGlTZXJ2aWNlLmdldEFwaVVybCgndXNlci9hdXRoL3Rva2VuL3JlZnJlc2gvJyksIHtcclxuICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJlZnJlc2g6IHJlZnJlc2hUb2tlbiB9KSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaFJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hEYXRhID0gYXdhaXQgcmVmcmVzaFJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIHJlZnJlc2hEYXRhLmFjY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG5ldyB0b2tlblxyXG4gICAgICAgICAgICAgICAgICBmZXRjaFVzZXJEYXRhKHJlZnJlc2hEYXRhLmFjY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGNhdGNoIChyZWZyZXNoRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkOicsIHJlZnJlc2hFcnJvcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgYm90aCB0b2tlbiB2ZXJpZnkgYW5kIHJlZnJlc2ggZmFpbGVkXHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgICAgICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBUb2tlbiBpcyB2YWxpZCwgZ2V0IHVzZXIgZGF0YVxyXG4gICAgICAgICAgYXdhaXQgZmV0Y2hVc2VyRGF0YSh0b2tlbik7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYXV0aFRva2VuJyk7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncmVmcmVzaFRva2VuJyk7XHJcbiAgICAgICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcclxuICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgICAgY29uc3QgZmV0Y2hVc2VyRGF0YSA9IGFzeW5jICh0b2tlbjogc3RyaW5nKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChBcGlTZXJ2aWNlLmdldEFwaVVybCgndXNlci9hdXRoL21lLycpLCB7XHJcbiAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAsXHJcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgICAgICAgIGlkOiB1c2VyRGF0YS5pZCxcclxuICAgICAgICAgICAgICBuYW1lOiB1c2VyRGF0YS5mdWxsX25hbWUgfHwgdXNlckRhdGEubmFtZSxcclxuICAgICAgICAgICAgICBlbWFpbDogdXNlckRhdGEuZW1haWwsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXNlciBhdXRoZW50aWNhdGVkIHN1Y2Nlc3NmdWxseSBvbiBwYWdlIHJlZnJlc2hcIik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBnZXQgdXNlciBkYXRhLCBzdGF0dXM6XCIsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgIC8vIFRva2VuIG1pZ2h0IGJlIHZhbGlkIGJ1dCB1c2VyIGRhdGEgZmV0Y2ggZmFpbGVkXHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgICAgICAgc2V0VXNlcihudWxsKTtcclxuICAgICAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikgeyAgICAgICAgICBjb25zb2xlLmVycm9yKCdBdXRoZW50aWNhdGlvbiBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F1dGhUb2tlbicpO1xyXG4gICAgICAgICAgc2V0VXNlcihudWxsKTtcclxuICAgICAgICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICB9O1xyXG5cclxuICAgIGNoZWNrQXV0aCgpO1xyXG4gIH0sIFtdKTtcclxuICBjb25zdCBsb2dpbldpdGhHb29nbGUgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAvLyBPcGVuIEdvb2dsZSBPQXV0aCBwb3B1cFxyXG4gICAgY29uc3Qgd2lkdGggPSA1MDA7XHJcbiAgICBjb25zdCBoZWlnaHQgPSA2MDA7XHJcbiAgICBjb25zdCBsZWZ0ID0gd2luZG93LnNjcmVlblggKyAod2luZG93Lm91dGVyV2lkdGggLSB3aWR0aCkgLyAyO1xyXG4gICAgY29uc3QgdG9wID0gd2luZG93LnNjcmVlblkgKyAod2luZG93Lm91dGVySGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XHJcbiAgICAgIC8vIENvbnN0cnVjdCBHb29nbGUgT0F1dGggVVJMXHJcbiAgICBjb25zdCBnb29nbGVPQXV0aFVybCA9IGBodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20vby9vYXV0aDIvdjIvYXV0aD9gICtcclxuICAgICAgYGNsaWVudF9pZD0ke0FwaVNlcnZpY2UuZ2V0Q29uZmlnKCkuZ29vZ2xlQ2xpZW50SWR9YCArXHJcbiAgICAgIGAmcmVkaXJlY3RfdXJpPSR7ZW5jb2RlVVJJQ29tcG9uZW50KEFwaVNlcnZpY2UuZ2V0Q29uZmlnKCkuZ29vZ2xlT0F1dGhSZWRpcmVjdFVyaSl9YCArXHJcbiAgICAgIGAmcmVzcG9uc2VfdHlwZT1pZF90b2tlbmAgK1xyXG4gICAgICBgJnNjb3BlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KCdvcGVuaWQgZW1haWwgcHJvZmlsZScpfWAgK1xyXG4gICAgICBgJm5vbmNlPSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KX1gICtcclxuICAgICAgYCZwcm9tcHQ9c2VsZWN0X2FjY291bnRgOy8vIE9wZW4gdGhlIEdvb2dsZSBPQXV0aCBwb3B1cFxyXG4gICAgY29uc3QgcG9wdXAgPSB3aW5kb3cub3BlbihcclxuICAgICAgZ29vZ2xlT0F1dGhVcmwsXHJcbiAgICAgICdHb29nbGUgTG9naW4nLFxyXG4gICAgICBgd2lkdGg9JHt3aWR0aH0saGVpZ2h0PSR7aGVpZ2h0fSxsZWZ0PSR7bGVmdH0sdG9wPSR7dG9wfSx0b29sYmFyPW5vLG1lbnViYXI9bm8sbG9jYXRpb249bm8sc3RhdHVzPW5vYFxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGEgbWVzc2FnZSBsaXN0ZW5lciB0byBoYW5kbGUgdGhlIGNhbGxiYWNrXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFzeW5jIChldmVudCkgPT4ge1xyXG4gICAgICAvLyBPbmx5IGFjY2VwdCBtZXNzYWdlcyBmcm9tIG91ciBvd24gZG9tYWluXHJcbiAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHJldHVybjtcclxuICAgICAgXHJcbiAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT09ICdHT09HTEVfQVVUSF9TVUNDRVNTJykge1xyXG4gICAgICAgIGlmIChwb3B1cCkgcG9wdXAuY2xvc2UoKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBoYW5kbGVHb29nbGVDYWxsYmFjayhldmVudC5kYXRhLnRva2VuLCBldmVudC5kYXRhLnVzZXIpO1xyXG4gICAgICAgICAgcm91dGVyLnB1c2goJy9wcm9maWxlJyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dvb2dsZSBhdXRoIGNhbGxiYWNrIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICB9ICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuICBjb25zdCBoYW5kbGVHb29nbGVDYWxsYmFjayA9IGFzeW5jICh0b2tlbjogc3RyaW5nLCB1c2VyRGF0YTogYW55KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICB0cnkgeyAgICAgIC8vIEV4Y2hhbmdlIHRoZSBHb29nbGUgYXV0aCB0b2tlbiBmb3Igb3VyIGFwcCBKV1RcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChBcGlTZXJ2aWNlLmdldEFwaVVybCgndXNlci9hdXRoL2dvb2dsZS90b2tlbi8nKSwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXHJcbiAgICAgICAgICBpZF90b2tlbjogdG9rZW4sIFxyXG4gICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxyXG4gICAgICAgICAgZnVsbF9uYW1lOiB1c2VyRGF0YS5uYW1lXHJcbiAgICAgICAgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8ICdHb29nbGUgYXV0aGVudGljYXRpb24gZmFpbGVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiR29vZ2xlIGF1dGggcmVzcG9uc2U6XCIsIGRhdGEpO1xyXG4gICAgICBcclxuICAgICAgLy8gU3RvcmUgdG9rZW5zIGJhc2VkIG9uIHdoYXQncyByZXR1cm5lZFxyXG4gICAgICBpZiAoZGF0YS5hY2Nlc3MpIHtcclxuICAgICAgICAvLyBKV1QgZm9ybWF0XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIGRhdGEuYWNjZXNzKTtcclxuICAgICAgICBpZiAoZGF0YS5yZWZyZXNoKSB7XHJcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncmVmcmVzaFRva2VuJywgZGF0YS5yZWZyZXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50b2tlbikge1xyXG4gICAgICAgIC8vIExlZ2FjeSB0b2tlbiBmb3JtYXRcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYXV0aFRva2VuJywgZGF0YS50b2tlbik7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgIGlkOiBkYXRhLnVzZXIuaWQsXHJcbiAgICAgICAgbmFtZTogZGF0YS51c2VyLmZ1bGxfbmFtZSxcclxuICAgICAgICBlbWFpbDogZGF0YS51c2VyLmVtYWlsLFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7ICAgICAgY29uc29sZS5lcnJvcignR29vZ2xlIGF1dGggZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IGxvZ2luID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdG9rZW5zIGZpcnN0XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChBcGlTZXJ2aWNlLmdldEFwaVVybCgndXNlci9hdXRoL2xvZ2luLycpLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIHBhc3N3b3JkIH0pLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ0xvZ2luIGZhaWxlZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coXCJMb2dpbiByZXNwb25zZTpcIiwgZGF0YSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdG9yZSB0b2tlbnMgLSB3ZSdyZSB1c2luZyBKV1Qgd2hpY2ggcmV0dXJucyBhY2Nlc3MgYW5kIHJlZnJlc2ggdG9rZW5zXHJcbiAgICAgIGlmIChkYXRhLmFjY2Vzcykge1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoVG9rZW4nLCBkYXRhLmFjY2Vzcyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50b2tlbikge1xyXG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBub24tSldUIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhUb2tlbicsIGRhdGEudG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZGF0YS5yZWZyZXNoKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JlZnJlc2hUb2tlbicsIGRhdGEucmVmcmVzaCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSB1c2VyIHN0YXRlXHJcbiAgICAgIHNldFVzZXIoe1xyXG4gICAgICAgIGlkOiBkYXRhLnVzZXI/LmlkLFxyXG4gICAgICAgIG5hbWU6IGRhdGEudXNlcj8uZnVsbF9uYW1lIHx8IGRhdGEudXNlcj8ubmFtZSxcclxuICAgICAgICBlbWFpbDogZGF0YS51c2VyPy5lbWFpbCB8fCBlbWFpbCxcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7IC8vIE1ha2Ugc3VyZSBsb2FkaW5nIGlzIGFsd2F5cyBzZXQgdG8gZmFsc2VcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IGxvZ291dCA9ICgpID0+IHtcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoVG9rZW4nKTtcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZWZyZXNoVG9rZW4nKTtcclxuICAgIHNldFVzZXIobnVsbCk7XHJcbiAgICBzZXRJc0F1dGhlbnRpY2F0ZWQoZmFsc2UpO1xyXG4gICAgLy8gUmVkaXJlY3QgdG8gbG9naW4gcGFnZVxyXG4gICAgcm91dGVyLnB1c2goJy9BdXRoZW50aWNhdGlvbi9sb2dpbicpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHZhbHVlID0ge1xyXG4gICAgdXNlcixcclxuICAgIGxvYWRpbmcsXHJcbiAgICBsb2dpbixcclxuICAgIGxvZ291dCxcclxuICAgIGxvZ2luV2l0aEdvb2dsZSxcclxuICAgIGhhbmRsZUdvb2dsZUNhbGxiYWNrLFxyXG4gICAgaXNBdXRoZW50aWNhdGVkLFxyXG4gIH07XHJcblxyXG4gIHJldHVybiA8QXV0aENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT57Y2hpbGRyZW59PC9BdXRoQ29udGV4dC5Qcm92aWRlcj47XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB1c2VBdXRoID0gKCkgPT4ge1xyXG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcclxuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUF1dGggbXVzdCBiZSB1c2VkIHdpdGhpbiBhbiBBdXRoUHJvdmlkZXInKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSb3V0ZXIiLCJBcGlTZXJ2aWNlIiwiQXV0aENvbnRleHQiLCJ1bmRlZmluZWQiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJzZXRVc2VyIiwibG9hZGluZyIsInNldExvYWRpbmciLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRJc0F1dGhlbnRpY2F0ZWQiLCJyb3V0ZXIiLCJjaGVja0F1dGgiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJ2ZXJpZnlSZXNwb25zZSIsImZldGNoIiwiZ2V0QXBpVXJsIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJjb25zb2xlIiwibG9nIiwic3RhdHVzIiwicmVmcmVzaFRva2VuIiwicmVmcmVzaFJlc3BvbnNlIiwicmVmcmVzaCIsInJlZnJlc2hEYXRhIiwianNvbiIsInNldEl0ZW0iLCJhY2Nlc3MiLCJmZXRjaFVzZXJEYXRhIiwicmVmcmVzaEVycm9yIiwiZXJyb3IiLCJyZW1vdmVJdGVtIiwicmVzcG9uc2UiLCJjcmVkZW50aWFscyIsInVzZXJEYXRhIiwiaWQiLCJuYW1lIiwiZnVsbF9uYW1lIiwiZW1haWwiLCJsb2dpbldpdGhHb29nbGUiLCJ3aWR0aCIsImhlaWdodCIsImxlZnQiLCJ3aW5kb3ciLCJzY3JlZW5YIiwib3V0ZXJXaWR0aCIsInRvcCIsInNjcmVlblkiLCJvdXRlckhlaWdodCIsImdvb2dsZU9BdXRoVXJsIiwiZ2V0Q29uZmlnIiwiZ29vZ2xlQ2xpZW50SWQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnb29nbGVPQXV0aFJlZGlyZWN0VXJpIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwicG9wdXAiLCJvcGVuIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50Iiwib3JpZ2luIiwibG9jYXRpb24iLCJkYXRhIiwidHlwZSIsImNsb3NlIiwiaGFuZGxlR29vZ2xlQ2FsbGJhY2siLCJwdXNoIiwiaWRfdG9rZW4iLCJlcnJvckRhdGEiLCJFcnJvciIsImxvZ2luIiwicGFzc3dvcmQiLCJkZXRhaWwiLCJsb2dvdXQiLCJ2YWx1ZSIsIlByb3ZpZGVyIiwidXNlQXV0aCIsImNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/Authentication/context/AuthContext.tsx\n"));

/***/ })

});